.. _spi_api:

Serial Peripheral Interface (SPI) Bus
######################################

Overview
********

The Serial Peripheral Interface (SPI) is a synchronous serial communication protocol used for
short-distance communication, primarily in embedded systems. SPI operates in full duplex mode
and uses a controller-peripheral architecture with a single controller and one or more peripheral
devices.

The SPI API provides a generic method to interact with SPI controllers and peripheral devices.
It allows applications to configure SPI buses, transfer data synchronously or asynchronously,
and manage chip select signals. Key features include:

**Controller and Peripheral Modes**
  Support for both controller (master) mode where the device controls the clock and chip select,
  and peripheral (slave) mode where the device responds to an external controller.

**Data Transfer**
  Synchronous blocking transfers, interrupt-driven transfers, and asynchronous transfers using DMA
  for efficient data communication.

**Flexible Configuration**
  Configure clock polarity (CPOL), clock phase (CPHA), bit order (MSB/LSB first), word size,
  and bus frequency per transfer.

**Chip Select Management**
  Hardware-controlled or GPIO-controlled chip select with configurable timing and polarity.

**Devicetree Integration**
  SPI devices and controllers are typically defined in the Devicetree, allowing
  drivers and applications to reference them in a hardware-agnostic way using
  :c:struct:`spi_dt_spec`.

SPI Concepts
************

SPI Bus Topology
================

An SPI bus consists of four main signals:

* **SCLK (Serial Clock)**: Clock signal generated by the controller
* **MOSI (Master Out Slave In)**: Data line from controller to peripheral
* **MISO (Master In Slave Out)**: Data line from peripheral to controller
* **CS (Chip Select)**: Signal to select a specific peripheral device (also called SS - Slave Select)

Multiple peripheral devices can share the same MOSI, MISO, and SCLK lines, but each peripheral
typically has its own dedicated CS line.

Clock Polarity and Phase
=========================

SPI supports four different clock modes, defined by two parameters:

* **CPOL (Clock Polarity)**: Determines the idle state of the clock
  
  * CPOL=0: Clock is low when idle
  * CPOL=1: Clock is high when idle

* **CPHA (Clock Phase)**: Determines when data is sampled
  
  * CPHA=0: Data is sampled on the leading (first) edge
  * CPHA=1: Data is sampled on the trailing (second) edge

The combination of CPOL and CPHA creates four SPI modes:

* **Mode 0** (CPOL=0, CPHA=0): Clock idle low, sample on leading edge
* **Mode 1** (CPOL=0, CPHA=1): Clock idle low, sample on trailing edge
* **Mode 2** (CPOL=1, CPHA=0): Clock idle high, sample on leading edge
* **Mode 3** (CPOL=1, CPHA=1): Clock idle high, sample on trailing edge

Devicetree Configuration
*************************

SPI Controllers
===============

SPI controllers are defined in the Devicetree as nodes with the ``spi`` bus type.
The ``#address-cells`` and ``#size-cells`` properties are required and typically set to 1 and 0,
respectively. The ``cs-gpios`` property can be used to specify GPIO-controlled chip select pins.

Example of an SPI controller definition:

.. code-block:: devicetree

   spi0: spi@40003000 {
       compatible = "nordic,nrf-spi";
       reg = <0x40003000 0x1000>;
       interrupts = <3 1>;
       #address-cells = <1>;
       #size-cells = <0>;
       cs-gpios = <&gpio0 17 GPIO_ACTIVE_LOW>,
                  <&gpio0 18 GPIO_ACTIVE_LOW>;
       status = "okay";
   };

SPI Devices
===========

SPI peripheral devices are defined as child nodes of the SPI controller. Each device must specify
a ``reg`` property indicating its chip select number and a ``spi-max-frequency`` property
specifying the maximum supported bus frequency.

Example of SPI device definitions:

.. code-block:: devicetree

   &spi0 {
       status = "okay";
       
       spi_flash: spi-flash@0 {
           compatible = "jedec,spi-nor";
           reg = <0>;
           spi-max-frequency = <8000000>;
           jedec-id = [ef 40 15];
           size = <0x400000>;
       };
       
       spi_sensor: sensor@1 {
           compatible = "vendor,spi-sensor";
           reg = <1>;
           spi-max-frequency = <4000000>;
           spi-cpol;
           spi-cpha;
       };
   };

Common SPI Device Properties
=============================

The following properties can be used in SPI device nodes:

* ``spi-max-frequency``: Maximum SPI bus frequency in Hz (required)
* ``spi-cpol``: Clock polarity (idle high when present)
* ``spi-cpha``: Clock phase (sample on trailing edge when present)
* ``spi-lsb-first``: LSB first bit order (MSB first is default)
* ``spi-hold-cs``: Keep chip select active between transactions
* ``spi-cs-high``: Chip select is active high (active low is default)
* ``spi-interframe-delay-ns``: Delay in nanoseconds between SPI words
* ``spi-cs-setup-delay-ns``: Delay after CS assertion
* ``spi-cs-hold-delay-ns``: Delay before CS de-assertion
* ``duplex``: Duplex mode (full duplex is default, half duplex optional)

Basic Operation
***************

SPI operations are typically performed on a :c:struct:`spi_dt_spec` structure, which is a
container for the SPI device information specified in the Devicetree.

This structure is populated using :c:macro:`SPI_DT_SPEC_GET` macro (or any of its variants).

.. code-block:: c
   :caption: Populating an spi_dt_spec structure for an SPI device defined as node ``spi_flash``

   #define SPI_FLASH_NODE DT_NODELABEL(spi_flash)
   static const struct spi_dt_spec spi_dev = SPI_DT_SPEC_GET(
       SPI_FLASH_NODE, SPI_OP_MODE_MASTER | SPI_WORD_SET(8), 0);

The :c:struct:`spi_dt_spec` structure can then be used to perform SPI operations.

Verifying Device Readiness
===========================

Before performing any operations, verify that the SPI device is ready:

.. code-block:: c

   if (!spi_is_ready_dt(&spi_dev)) {
       printk("SPI device not ready\n");
       return -ENODEV;
   }

Synchronous Data Transfer
==========================

The most common SPI operation is a synchronous transfer using :c:func:`spi_transceive_dt`.
This function performs a full-duplex transfer, simultaneously sending and receiving data.

.. code-block:: c
   :caption: Performing a synchronous SPI transfer

   uint8_t tx_buffer[] = {0x01, 0x02, 0x03, 0x04};
   uint8_t rx_buffer[4];
   
   const struct spi_buf tx_buf = {
       .buf = tx_buffer,
       .len = sizeof(tx_buffer)
   };
   const struct spi_buf_set tx = {
       .buffers = &tx_buf,
       .count = 1
   };
   
   struct spi_buf rx_buf = {
       .buf = rx_buffer,
       .len = sizeof(rx_buffer)
   };
   const struct spi_buf_set rx = {
       .buffers = &rx_buf,
       .count = 1
   };
   
   int ret = spi_transceive_dt(&spi_dev, &tx, &rx);
   if (ret < 0) {
       printk("SPI transceive failed: %d\n", ret);
       return ret;
   }

Write-Only and Read-Only Transfers
===================================

For write-only operations, use :c:func:`spi_write_dt` with NULL for the receive buffer:

.. code-block:: c
   :caption: Writing data to an SPI device

   uint8_t cmd[] = {0x06}; // Write enable command
   
   const struct spi_buf tx_buf = {
       .buf = cmd,
       .len = sizeof(cmd)
   };
   const struct spi_buf_set tx = {
       .buffers = &tx_buf,
       .count = 1
   };
   
   int ret = spi_write_dt(&spi_dev, &tx);
   if (ret < 0) {
       printk("SPI write failed: %d\n", ret);
   }

For read-only operations, use :c:func:`spi_read_dt`:

.. code-block:: c
   :caption: Reading data from an SPI device

   uint8_t rx_data[16];
   
   struct spi_buf rx_buf = {
       .buf = rx_data,
       .len = sizeof(rx_data)
   };
   const struct spi_buf_set rx = {
       .buffers = &rx_buf,
       .count = 1
   };
   
   int ret = spi_read_dt(&spi_dev, &rx);
   if (ret < 0) {
       printk("SPI read failed: %d\n", ret);
   }

Refer to :zephyr:code-sample:`spi-nor` for a complete example of basic SPI operations using the
:c:struct:`spi_dt_spec` structure to interact with a SPI NOR flash device.

Scatter-Gather Transfers
=========================

The SPI API supports scatter-gather transfers, allowing multiple buffers to be transferred
in a single transaction without releasing the chip select:

.. code-block:: c
   :caption: Performing a scatter-gather transfer

   uint8_t cmd = 0x03;        // Read command
   uint8_t addr[3] = {0x00, 0x10, 0x00}; // Address
   uint8_t data[256];         // Data buffer
   
   const struct spi_buf tx_bufs[] = {
       { .buf = &cmd, .len = 1 },
       { .buf = addr, .len = sizeof(addr) },
       { .buf = NULL, .len = sizeof(data) }  // NOP for RX
   };
   const struct spi_buf_set tx = {
       .buffers = tx_bufs,
       .count = ARRAY_SIZE(tx_bufs)
   };
   
   struct spi_buf rx_bufs[] = {
       { .buf = NULL, .len = 1 },               // Ignore command echo
       { .buf = NULL, .len = sizeof(addr) },    // Ignore address echo
       { .buf = data, .len = sizeof(data) }     // Actual data
   };
   const struct spi_buf_set rx = {
       .buffers = rx_bufs,
       .count = ARRAY_SIZE(rx_bufs)
   };
   
   int ret = spi_transceive_dt(&spi_dev, &tx, &rx);

Advanced Features
*****************

Asynchronous Transfers
======================

When :kconfig:option:`CONFIG_SPI_ASYNC` is enabled, the SPI API supports asynchronous transfers
that use callbacks to notify completion:

.. code-block:: c
   :caption: Performing an asynchronous SPI transfer

   static void spi_callback(const struct device *dev, int result, void *data)
   {
       if (result == 0) {
           printk("SPI transfer completed successfully\n");
       } else {
           printk("SPI transfer failed: %d\n", result);
       }
   }
   
   int ret = spi_transceive_signal(spi_dev.bus, &spi_dev.config,
                                     &tx, &rx, spi_callback, NULL);
   if (ret < 0) {
       printk("Failed to start async transfer: %d\n", ret);
   }

Resource Locking
================

The SPI API provides a mechanism to lock the SPI bus for exclusive access using the
:c:macro:`SPI_LOCK_ON` flag. This is useful when multiple transactions need to be performed
atomically:

.. code-block:: c
   :caption: Using SPI resource locking

   struct spi_config config = {
       .frequency = 1000000,
       .operation = SPI_OP_MODE_MASTER | SPI_WORD_SET(8) | SPI_LOCK_ON,
       .slave = 0,
   };
   
   // First transaction acquires lock
   ret = spi_transceive(spi_dev.bus, &config, &tx1, &rx1);
   
   // Subsequent transactions with same config keep the lock
   ret = spi_transceive(spi_dev.bus, &config, &tx2, &rx2);
   
   // Release the lock explicitly
   ret = spi_release(spi_dev.bus, &config);

GPIO Chip Select Control
=========================

Chip select can be controlled via GPIO for more flexibility. The :c:struct:`spi_cs_control`
structure is used to specify GPIO-based chip select:

.. code-block:: c
   :caption: Configuring GPIO chip select

   static struct spi_cs_control cs_ctrl = {
       .gpio = SPI_CS_GPIOS_DT_SPEC_GET(SPI_FLASH_NODE),
       .delay = 0,
   };
   
   static struct spi_config spi_cfg = {
       .frequency = 1000000,
       .operation = SPI_OP_MODE_MASTER | SPI_WORD_SET(8),
       .slave = 0,
       .cs = cs_ctrl,
   };

Direct Device Access
=====================

SPI operations can also be performed directly on an SPI controller device without using
the :c:struct:`spi_dt_spec` structure. In this case, use the API functions that take
a device pointer and :c:struct:`spi_config` as arguments, such as :c:func:`spi_transceive`,
:c:func:`spi_write`, and :c:func:`spi_read`.

.. code-block:: c
   :caption: Direct SPI device access

   const struct device *spi_dev = DEVICE_DT_GET(DT_NODELABEL(spi0));
   
   struct spi_config config = {
       .frequency = 1000000,
       .operation = SPI_OP_MODE_MASTER | SPI_WORD_SET(8),
       .slave = 0,
   };
   
   ret = spi_transceive(spi_dev, &config, &tx, &rx);

Statistics and Monitoring
==========================

When :kconfig:option:`CONFIG_SPI_STATS` is enabled, the SPI subsystem collects statistics
on data transfers, including the number of bytes transmitted and received, and transfer errors.
These statistics can be useful for debugging and monitoring SPI bus activity.

Configuration Options
*********************

Main configuration options:

* :kconfig:option:`CONFIG_SPI` - Enable SPI driver support
* :kconfig:option:`CONFIG_SPI_ASYNC` - Enable asynchronous transfer API
* :kconfig:option:`CONFIG_SPI_RTIO` - Enable RTIO-based transfers
* :kconfig:option:`CONFIG_SPI_SLAVE` - Enable SPI peripheral (slave) mode support
* :kconfig:option:`CONFIG_SPI_EXTENDED_MODES` - Enable extended modes (dual, quad, octal)
* :kconfig:option:`CONFIG_SPI_STATS` - Enable SPI statistics collection
* :kconfig:option:`CONFIG_SPI_SHELL` - Enable SPI shell commands for debugging

API Reference
*************

.. doxygengroup:: spi_interface
