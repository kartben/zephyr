#!/usr/bin/env python3
#
# Copyright 2025 Linaro
# Copyright 2025 Antmicro
# Copyright 2025 Analog Devices
#
# SPDX-License-Identifier: Apache-2.0

"""Native Python CTF (Common Trace Format) parser for Zephyr instrumentation.

This module provides a pure Python implementation to parse CTF 1.8 binary trace
data generated by Zephyr's instrumentation subsystem. It replaces the bt2
(babeltrace2) dependency to make the tool more portable across platforms.
"""

import struct


class CTFEvent:
    """Represents a single CTF event with its parsed fields."""

    def __init__(self, event_id, name, fields):
        self.id = event_id
        self.name = name
        self.payload_field = fields

    def get_field(self, field_name):
        """Get a field value by name."""
        return self.payload_field.get(field_name)


class CTFEventField:
    """Wrapper for event field values to match bt2 API."""

    def __init__(self, value):
        self._value = value

    @property
    def real(self):
        """Get the real (integer) value of the field."""
        return self._value

    def __str__(self):
        return str(self._value)

    def __repr__(self):
        return repr(self._value)


# Base class for compatibility with code that checks isinstance(msg, bt2._EventMessageConst)
class _EventMessageConst:
    """Base class for event messages, compatible with bt2 API."""
    pass


class CTFEventMessage(_EventMessageConst):
    """Wrapper for CTF event messages to match bt2 API."""

    def __init__(self, event):
        self.event = event


class CTFParser:
    """Parser for CTF binary trace data based on Zephyr's metadata format.

    This parser understands the specific CTF format generated by Zephyr's
    instrumentation subsystem as defined in subsys/instrumentation/ctf/metadata.
    """

    # Event IDs from metadata
    EVENT_FUNC_ENTRY_WITH_CONTEXT = 0
    EVENT_FUNC_EXIT_WITH_CONTEXT = 1
    EVENT_PROFILE = 2
    EVENT_SCHED_SWITCHED_IN = 3
    EVENT_SCHED_SWITCHED_OUT = 4

    def __init__(self, data_file_path):
        """Initialize the parser with a binary data file path.

        Args:
            data_file_path: Path to the CTF binary data file
        """
        self.data_file_path = data_file_path
        with open(data_file_path, 'rb') as f:
            self.data = f.read()
        self.offset = 0

    def __iter__(self):
        """Iterate over events in the trace."""
        self.offset = 0
        return self

    def __next__(self):
        """Get the next event from the trace."""
        if self.offset >= len(self.data):
            raise StopIteration

        try:
            # Read event header (1 byte - event ID)
            if self.offset + 1 > len(self.data):
                raise StopIteration

            event_id = struct.unpack_from('<B', self.data, self.offset)[0]
            self.offset += 1

            # Parse based on event type
            if event_id in (
                self.EVENT_FUNC_ENTRY_WITH_CONTEXT,
                self.EVENT_FUNC_EXIT_WITH_CONTEXT,
                self.EVENT_SCHED_SWITCHED_IN,
                self.EVENT_SCHED_SWITCHED_OUT
            ):
                event = self._parse_context_event(event_id)
            elif event_id == self.EVENT_PROFILE:
                event = self._parse_profile_event(event_id)
            else:
                # Unknown event type, skip
                raise StopIteration

            return CTFEventMessage(event)

        except struct.error:
            # Not enough data to parse, end of trace
            raise StopIteration

    def _parse_context_event(self, event_id):
        """Parse events with context (entry/exit/sched events).

        Event structure from metadata:
        - uint32_t callee
        - uint32_t caller
        - uint64_t timestamp
        - uint3_t mode (3 bits)
        - uint3_t cpu (3 bits)
        - uint2_t rsvd (2 bits)
        - uint32_t thread_id
        - string_t thread_name[20] (20 bytes)

        Total: 4 + 4 + 8 + 1 + 4 + 20 = 41 bytes
        """
        # Check if we have enough data
        if self.offset + 41 > len(self.data):
            raise struct.error("Not enough data")

        # Parse fixed fields
        callee, caller, timestamp = struct.unpack_from('<IIQ', self.data, self.offset)
        self.offset += 16

        # Parse bit fields (mode, cpu, rsvd in 1 byte)
        bitfield = struct.unpack_from('<B', self.data, self.offset)[0]
        self.offset += 1
        mode = bitfield & 0x07  # 3 bits
        cpu = (bitfield >> 3) & 0x07  # 3 bits
        # rsvd = (bitfield >> 6) & 0x03  # 2 bits (unused)

        # Parse thread_id
        thread_id = struct.unpack_from('<I', self.data, self.offset)[0]
        self.offset += 4

        # Parse thread_name (20 bytes, null-terminated string)
        thread_name_bytes = struct.unpack_from('20s', self.data, self.offset)[0]
        self.offset += 20
        # Decode as ASCII, strip null bytes and whitespace
        thread_name = thread_name_bytes.decode('ascii', errors='ignore').rstrip('\x00')

        # Determine event name based on ID
        event_names = {
            self.EVENT_FUNC_ENTRY_WITH_CONTEXT: 'func_entry_with_context',
            self.EVENT_FUNC_EXIT_WITH_CONTEXT: 'func_exit_with_context',
            self.EVENT_SCHED_SWITCHED_IN: 'sched_switched_in',
            self.EVENT_SCHED_SWITCHED_OUT: 'sched_switched_out',
        }
        event_name = event_names[event_id]

        # Create fields dictionary matching bt2 API
        fields = {
            'callee': CTFEventField(callee),
            'caller': CTFEventField(caller),
            'timestamp': CTFEventField(timestamp),
            'mode': CTFEventField(mode),
            'cpu': CTFEventField(cpu),
            'thread_id': CTFEventField(thread_id),
            'thread_name': CTFEventField(thread_name),
        }

        return CTFEvent(event_id, event_name, fields)

    def _parse_profile_event(self, event_id):
        """Parse profile event.

        Event structure from metadata:
        - uint32_t callee
        - uint64_t delta_t

        Total: 4 + 8 = 12 bytes
        """
        # Check if we have enough data
        if self.offset + 12 > len(self.data):
            raise struct.error("Not enough data")

        # Parse fields
        callee, delta_t = struct.unpack_from('<IQ', self.data, self.offset)
        self.offset += 12

        # Create fields dictionary matching bt2 API
        fields = {
            'callee': CTFEventField(callee),
            'delta_t': CTFEventField(delta_t),
        }

        return CTFEvent(event_id, 'profile', fields)


class TraceCollectionMessageIterator:
    """Main iterator for CTF traces, compatible with bt2 API.

    This class mimics the bt2.TraceCollectionMessageIterator interface
    to allow drop-in replacement in the zaru.py script.
    """

    def __init__(self, trace_directory):
        """Initialize the iterator with a trace directory.

        Args:
            trace_directory: Directory containing 'data' and 'metadata' files
        """
        import os
        data_file = os.path.join(trace_directory, 'data')
        # We don't need to parse the metadata file since we know the format
        # from Zephyr's fixed metadata structure
        self.parser = CTFParser(data_file)

    def __iter__(self):
        """Return the iterator."""
        return self.parser

    def __next__(self):
        """Get the next message."""
        return next(self.parser)
